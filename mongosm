#!/usr/bin/env node

/* jshint -W004 */

var fs = require("fs"),
    options = require('./options.js');

var mongoose = require("./schema/index.js")(options),
    saxStream = require("sax").createStream(options.strict, options),
    async = require("async");

require('date-utils');

var startTime = new Date()

require('./commandline.js')(options);

var Node = mongoose.db.model('node');
var Way = mongoose.db.model('way');
var Relation = mongoose.db.model('relation');
var entry;
var relationIsDependant = false;

// Reading

var finishedReadingNodes = false;
var finishedReadingWays = false;
var finishedReadingRelations = false;

// Accounting

var inputNodes = 0;
var outputNodes = 0;
var inputWays = 0;
var outputWays = 0;
var inputDependantRelations = 0;
var outputDependantRelations = 0;
var inputIndependantRelations = 0;
var outputIndependantRelations = 0;

var models = { node: Node, way: Way, relation: Relation };

var wayQueue = async.queue(function (way, callback) {
  var isCircularId = way.loc.nodes[0] === way.loc.nodes[way.loc.nodes.length-1];
  var isCircularLtLng = false;

  if (!!options.way.populateGeometry) {
    Node.find(
    {osm_id:{$in: way.loc.nodes}},
    {"loc.coordinates":true, "osm_id":true, _id:false},
    function (err, doc) {

      if (err) return console.log(err, way);
      if (!!!options.way.nodeIdList){
        way.set('loc.nodes', undefined);
      }

      var i = way.loc.nodes.length;
      var coords = [];

      for (i;i--;) {// array to match to
        var b = doc.length;
        for (b;b--;) {// array being matched
          if (doc[b].osm_id == way.loc.nodes[i]) {
            coords.unshift(doc[b].loc.coordinates);
            continue;
          }
        }
      }

      way.set('loc.coordinates', coords);
      isCircularLtLng = coords[0] === coords[coords.length-1];

      if (isCircularId || isCircularLtLng ) {
        way.set( 'loc.type', 'Polygon');
      } else {
        way.set( 'loc.type', 'LineString');
      }

      save(Way, way);
    });
  } else {
    if (!!!options.way.nodeIdList){
      way.set('loc.nodes', undefined);
    }

    save(Way, way);
  }
  callback();
}, 0);

function processRelation(relation) {
  // TODO: Create different geometries depending on the relations tags, e.g. type=multipolygon should be a
  //       MultiPolygon.
  // TODO: The following might also break if a relation includes a relation as a member, but the
  //       included relation has not been processed yet.
  var counter = relation.members.length;
  var features = [];

  for (var index = 0; index < relation.members.length; index++) {
    (function(index) {
      var member = relation.members[index];
      var query = options.useOriginalID ? { _id: parseInt(member.ref) } : { osm_id: parseInt(member.ref)};
      models[member.type].findOne(query, function(err, object) {
        if (err) { console.log(err); return; }

        if (object == null) {
          console.log("Warning, generating incomplete geometry for relation " + relation.osm_id + " due to missing member " + member.ref + " (" + member.type + ")");
          object = { loc: undefined }; // Such that the following code will not break
        }

        features[index] = { type: "Feature", geometry: object.loc, role: member.role };
        // TODO: Slightly non standard here as the above feature contains a role?
        counter--;
        if (counter == 0) {
          relation.set("loc", { type: "FeatureCollection", features: features });
          save(Relation, relation);
        }
      });
    })(index);
  }
}

var independantRelationQueue = async.queue(function(relation, callback) {
  processRelation(relation);
  callback();
}, 0);

var dependantRelationQueue = []

function sortDependantRelations() {
  for (var i=0; i<dependantRelationQueue.length; i++) {
    var relation = dependantRelationQueue[i];

    // Create a list of all the members which are relations
    var relationMembers = []
    for (var m=0; m<relation.members.length; m++) {
      var member = relation.members[m];
      if (member.type === "relation")
        relationMembers.push(parseInt(member.ref));
    }

    // For every relation that is scheduled to be processed after this one
    for (var j=i+1; j<dependantRelationQueue.length; j++) {
      var otherRelation = dependantRelationQueue[j];

      // Check if it is depended on by 'relation'
      if (relationMembers.indexOf(otherRelation.osm_id) != -1) {
        // If so, swap them
        dependantRelationQueue[i] = otherRelation;
        dependantRelationQueue[j] = relation;
        // Then process 'otherRelation' (now at position i)
        i--; // Repeat for i
        break;
      }
    }
  }
}

mongoose.connection.on('open', function () {

  console.log("Starting to process the nodes");
  log();
  // TODO: add dots to show activity every 2 sec?
  saxStream.on("opentag", parse);
  saxStream.onclosetag = closetag;
  fs.createReadStream(options.filename)
    .pipe(saxStream);

  saxStream.on("end", function() {
    finishedReadingRelations = true;
    console.log("Finished reading relations");
  });

  saxStream.on("error", function (e) {
    console.error("error!", e);
    this._parser.error = null;
    this._parser.resume();
  });
});

var lastOutputNodes = 0;
var lastInputNodes = 0;
var lastOutputWays = 0;
var lastInputWays = 0;
var lastOutputRelations = 0;
var lastInputRelations = 0;

function log() {
  var nodeReadSpeed = inputNodes - lastInputNodes;
  var nodeWriteSpeed = outputNodes - lastOutputNodes;
  var wayReadSpeed = inputWays - lastInputWays;
  var wayWriteSpeed = outputWays - lastOutputWays;

  console.log("nodes: " + outputNodes + "/" + inputNodes + " read speed: " + nodeReadSpeed + " write speed: " + nodeWriteSpeed);
  console.log("ways: " + outputWays + "/" + inputWays + " read speed: " + wayReadSpeed + " write speed: " + wayWriteSpeed);
  console.log("relations: " + (outputDependantRelations + outputIndependantRelations) + "/" + (inputDependantRelations + inputIndependantRelations));

  lastOutputNodes = outputNodes;
  lastInputNodes = inputNodes;
  lastOutputWays = outputWays;
  lastInputWays = inputWays;

  setTimeout(log, 1000);
}

function parse (xmlNode)  {

  switch(xmlNode.name)
  {
    case "node":
      inputNodes++;
      entry = new Node();
      var lat = parseFloat( xmlNode.attributes.lat.value );
      var lng = parseFloat( xmlNode.attributes.lon.value );
      entry.set("loc.coordinates", [lng,lat]);
      prepBaseNode(xmlNode);
      break;

    case "tag":
      var key   = "tags." + xmlNode.attributes.k.value.replace(/:/, "."),
          value = xmlNode.attributes.v.value;
      entry.set(key, value);
      break;

    case "nd":
      entry.loc.nodes.push(parseInt(xmlNode.attributes.ref.value, 10));
      break;

    case "way":
      inputWays++;
      finishedReadingNodes = true;
      entry = new Way();
      prepBaseNode(xmlNode);
      break;

    case "member":
      var member = {};
      for (var attribute in xmlNode.attributes) {
        // TODO: this does not account for namespacing
        if (attribute === "type" && xmlNode.attributes[attribute].value === "relation")
          relationIsDependant = true;
        member[attribute] = xmlNode.attributes[attribute].value;
      }
      entry.members.push(member);
      break;

    case "relation":
      finishedReadingWays = true;
      entry = new Relation();
      entry.members = [];
      prepBaseNode(xmlNode);
      break;

    case "osm":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    case "bounds":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    default:
      console.log(xmlNode);
      break;
  }
}

function closetag (tagName) {
  switch(tagName)
  {
    case "node":
      var node = entry;
      node.set("loc.type", "Point");
      save(Node, node);
      break;

    case "way":
      wayQueue.push(entry);
      finishedWays = true;
      break;

    case "relation":
      if (relationIsDependant) {
        inputDependantRelations++;
        dependantRelationQueue.push(entry);
        console.log("Adding dependant relation " + entry.osm_id);
        relationIsDependant = false;
      } else {
        inputIndependantRelations++;
        console.log("Adding independant relation " + entry.osm_id);
        independantRelationQueue.push(entry);
      }
      break;
  }
}

function prepBaseNode (xmlNode) {
  entry.set("osm_id",  xmlNode.attributes.id.value);
  entry.set("type",  xmlNode.name);
  for (var attribute in xmlNode.attributes) {
    if (attribute === "id" || attribute === "lat" || attribute === "lon") continue;
    entry.set(attribute, xmlNode.attributes[attribute].value);
  }
}

function end() {
  console.log("Finished processing " + (outputIndependantRelations + outputDependantRelations) + " relations");
  var endTime = new Date();

  var hours = startTime.getHoursBetween(endTime);
  var minutes = startTime.getMinutesBetween(endTime) - (hours * 60);
  var seconds = startTime.getSecondsBetween(endTime) - (minutes * 60);

  process.stdout.write("Finished in " + seconds + " seconds ");
  if (minutes == 1) process.stdout.write(minutes + " minute ");
    else if (minutes > 1) process.stdout.write(minutes + " minutes ");
  if (hours == 1) process.stdout.write(hours + " hour");
    else if (hours > 1) process.stdout.write(hours + "hours ");
  process.stdout.write("\n");

  mongoose.connection.close();
}

// Saves a object (node, way or relation), the coresponding model (Node, Way, or Relation)
// should also be given as this is used to update (if required).
function save(model, object) {
  if (options.upsert === true) {
    var value = object.toObject();
    var query = options.useOriginalID ? { _id: value._id } : { osm_id: value.osm_id };
    delete value._id;
    model.findOneAndUpdate(query, value, {upsert: true}, function(err) {
      if (err)
        console.log(err);
    });
  } else {
    object.save(function(err) {
      if (err)
        console.log(err);
      switch(model) {
        case Node:
          outputNodes++;
          // if we have begun processing ways, and we have just saved the last node
          if (finishedReadingNodes && outputNodes == inputNodes) {
            finishedNodes = true;
            console.log("Finished processing " + outputNodes + " nodes");
            console.log("Starting to process the ways");
            // start processing the ways
            wayQueue.concurrency = 1;
            wayQueue.process();
          }
          break;
        case Way:
          outputWays++;
          if (finishedReadingWays && outputWays == inputWays) {
            console.log("Finished processing " + outputWays + " ways");
            console.log("Starting to process the relations");
            // start processing the relations
            independantRelationQueue.concurrency = 1;
            independantRelationQueue.process();
          }
          break;
        case Relation:
          if (finishedReadingRelations) {
            // If the processing of the independant relations has finished?
            if (inputIndependantRelations === outputIndependantRelations) {
              // This must be a dependant relation
              outputDependantRelations++;

              // If the processing of the dependant relations has finished
              if (outputDependantRelations === inputDependantRelations) {
                end();
              } else {
                // Process the next dependant relation
                processRelation(dependantRelationQueue[outputDependantRelations]);
              }
            } else {
              outputIndependantRelations++;

              // If this is the last independant relation to be processed
              if (inputIndependantRelations === outputIndependantRelations) {
                if (dependantRelationQueue.length > 0) {
                  // First sort the dependant relations
                  sortDependantRelations();
                  // Then start the processing
                  processRelation(dependantRelationQueue[0]);
                }
              } else {
                end();
              }
            }
          } else {
            // This must be a independant relation, as they can be processed before all the
            // relations have been read
            outputIndependantRelations++;
          }

          break;
      }

    });
  }
}
