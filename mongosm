#!/usr/bin/env node


/* jshint -W004 */

var fs = require("fs"),
    options = require('options.js');

var mongoose = require("schema/index.js")(options),
    saxStream = require("sax").createStream(options.strict, options);

require('commandline.js')(options);
require('arrayHelper.js');

var Node = mongoose.db.model('node');
var Way = mongoose.db.model('way');
var Relation = mongoose.db.model('relation');
var entry;

mongoose.connection.on('open', function () {

  // TODO: add dots to show activity every 2 sec?
  saxStream.on("opentag", parse);
  saxStream.onclosetag = closetag;
  fs.createReadStream(options.filename)
    .pipe(saxStream);

  saxStream.on("end", shutDown);

  saxStream.on("error", function (e) {
    console.error("error!", e);
    this._parser.error = null;
    this._parser.resume();
  });
});

function parse (xmlNode)  {

  switch(xmlNode.name)
  {
    case "node":
      entry = new Node();
      var lat = parseFloat( xmlNode.attributes.lat.value );
      var lng = parseFloat( xmlNode.attributes.lon.value );
      entry.set("loc.coordinates", [lng,lat]);
      prepBaseNode(xmlNode);
      break;

    case "tag":
      var key   = "tags." + xmlNode.attributes.k.value.replace(/:/, "."),
          value = xmlNode.attributes.v.value;
      entry.set(key, value);
      break;

    case "nd":
      entry.loc.nodes.push(parseInt(xmlNode.attributes.ref.value));
      break;

    case "way":
      entry = new Way();
      prepBaseNode(xmlNode);
      break;

    case "member":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        // TODO: this does not account for namespacing
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      var coord = entry.get("loc.coordinates", Array) || [];

      // TODO: this should be an object not a string
      coord.push(JSON.stringify(val));
      entry.set("loc.coordinates", coord);
      break;

    case "relation":
      entry = new Relation();
      entry.set("_id", xmlNode.attributes.id.value);
      entry.set("loc", {type:"MultiPolygon", coordinates: []});
      prepBaseNode(xmlNode);
      break;

    case "osm":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    case "bounds":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    default:
      console.log(xmlNode);
      break;
  }
}

function closetag (tagName) {
  switch(tagName)
  {
    case "node":
      var node = entry;
      node.set("loc.type", "Point");
      save(Node, node);
      break;

    case "way":
      var isCircularId = entry.loc.nodes[0] === entry.loc.nodes[entry.loc.nodes.length-1];
      var isCircularLtLng = false;

      // Create a local reference to entry, such that it can be used in the callback
      var way = entry;

      if (!!options.way.populateGeometry) {
        Node.find(
        {osm_id:{$in: way.loc.nodes}},
        {"loc.coordinates":true, _id:false},
        function (err, doc) {

          // doc = doc.matchOrder(way.loc.nodes);

          if (err) return console.log(err, way);
          if (!!!options.way.nodeIdList){
            way.set('loc.nodes', undefined);
          }

          doc.forEach(function (elm, index) {
            way.loc.coordinates.push(elm.loc.coordinates);
          });

          var coord = way.loc.coordinates
          isCircularLtLng = coord[0] === coord[coord.length-1]

          if (isCircularId || isCircularLtLng ) {
            way.set( 'loc.type', 'Polygon');
          } else {
            way.set( 'loc.type', 'LineString');
          }

          save(Way, way);
        });
      } else {
        if (!!!options.way.nodeIdList){
          way.set('loc.nodes', undefined);
        }

        save(Way, way);
      }

      break;

    case "relation":
      var relation = entry;
      save(Relation, relation);
      break;
  }
}

function prepBaseNode (xmlNode) {
  entry.set("osm_id",  xmlNode.attributes.id.value);
  entry.set("type",  xmlNode.name);
  for (var attribute in xmlNode.attributes) {
    if (attribute === "id" || attribute === "lat" || attribute === "lon") continue;
    entry.set(attribute, xmlNode.attributes[attribute].value);
  }
}

function shutDown() {
  process.stdout.write("\n\nEOF: Ctrl-C to Exit\n\n");

  // on small files this closes early
  // implementing manual exit
  // mongoose.connection.close();
}

// Saves a object (node, way or relation), the coresponding model (Node, Way, or Relation)
// should also be given as this is used to update (if required).
function save(model, object) {
  if (options.upsert == true) {
    var value = object.toObject();
    var query = options.useOriginalID ? { _id: value._id } : { osm_id: value.osm_id };
    delete value._id;
    model.findOneAndUpdate(query, value, {upsert: true}, function(err) {
      if (err)
        console.log(err);
    });
  } else {
    object.save(function(err) {
      if (err)
        console.log(err);
    });
  }
}

