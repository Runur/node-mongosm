#!/usr/bin/env node


/* jshint -W004 */

var fs = require("fs"),
    options = require("options.js"),
    mongoose = require("schema/index.js"),
    entry;

// Options validation

function validateObjectOptions(object) {
  if ('keptAttributes' in object) {
    if ('ignoredAttributes' in object) {
      console.log("warning: removing ignoredAttributes as you have given the keptAttributes");
      delete object.ignoredAttributes;
    }
  } else {
    if (!('ignoredAttributes' in object)) {
      object.ignoredAttributes = [];
    }
  }
}

['node', 'way', 'relation'].forEach(function(object) {
  if (options[object] == undefined) {
    options[object] = { ignoredAttributes: [] };
  } else {
    validateObjectOptions(options[object]);
  }
});


var saxStream = require("sax").createStream(options.strict, options);
var db = mongoose.connect(serverString());

function serverString () {
  return 'mongodb://' + options.host + ':' + options.port + '/' + options.database;
}

var Node = db.model('node'),
    Way = db.model('way'),
    Relation = db.model('relation');

mongoose.connection.on('open', function () {

  // TODO: add dots to show activity every 2 sec?
  saxStream.on("opentag", parse);
  fs.createReadStream(options.filename)
    .pipe(saxStream);

  saxStream.on("end", shutDown);

  saxStream.on("error", function (e) {
    console.error("error!", e);
    this._parser.error = null;
    this._parser.resume();
  });

});

mongoose.connection.on('error', function (err) {
  console.log(err);
  function reconnect () {
    db = mongoose.connect('mongodb://' + options.host + '/' + options.database);
  };
  var id = setTimeout(reconnect, 5000)
});

process.argv.forEach(function (val, index, array) {
  function logHelp () {
    console.log([
      ["-v", "verbose"],
      ["-f", "file path"],
      ["-l", "to lowercase"],
      ["-u", "upcert all entries : defaults to save"],
      ["-host", "host name"],
      ["-port", "port"],
      ["-db", "database"],
      ["-h", "help"]
    ]);
  }

  if (index > 1) {
    switch (val) {
      case "-v":
        options.verbose = true;
        break;
      case "-l":
        options.lowercase = true;
        break;
      case "-u":
        options.upsert = true;
        break;
      case "-f":
        options.filename = array.splice(index+1,1)[0];
        break;
      case "-host":
        options.host = array.splice(index+1,1)[0];
        break;
      case "-port":
        options.port = array.splice(index+1,1)[0];
        break;
      case "-db":
        options.database = array.splice(index+1,1)[0];
        break;
      default:
        logHelp();
        process.kill()
        break;
    }
  }
});

function parse (xmlNode)  {

  switch(xmlNode.name)
  {
    
    case "node":
      if (!!entry) {
        save();
      }
      entry = new Node();
      var lat = parseFloat( xmlNode.attributes.lat.value );
      var lng = parseFloat( xmlNode.attributes.lon.value );
      entry.set("_id", xmlNode.attributes.id.value);
      entry.set("loc.coordinates", [lng,lat]);
      entry.set("loc.type", "Point");
      prepBaseNode(xmlNode);
      break;

    case "tag":
      var key   = "tags." + xmlNode.attributes.k.value.replace(/:/, "."),
          value = xmlNode.attributes.v.value;
      entry.set(key, value);
      break;

    case "nd":
      var ref = xmlNode.attributes.ref.value;
      var coord = entry.get("loc", Array) || [];
      coord.push(ref);
      entry.set("loc.coordinates",  coord);
      break;

    case "way":
      if (!!entry) {
        save();
      }
      entry = new Way();
      entry.set("_id", xmlNode.attributes.id.value);
      entry.set("loc",[]);
      prepBaseNode(xmlNode);
      break;

    case "member":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        // TODO: this does not account for namespacing
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      var coord = entry.get("loc.coordinates", Array) || [];

      // TODO: this should be an object not a string
      coord.push(JSON.stringify(val));
      entry.set("loc.coordinates", coord);
      break;

    case "relation":
      if (!!entry) {
        save();
      }
      entry = new Relation();
      entry.set("_id", xmlNode.attributes.id.value);
      entry.set("loc", {type:"MultiPolygon", coordinates: []});
      prepBaseNode(xmlNode);
      break;

    case "osm":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    case "bounds":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    default:
      console.log(xmlNode);
      break;
  }
}

function prepBaseNode (xmlNode) { 

  if (!!options.useOriginalID) {
    entry.set("_id",  xmlNode.attributes.id.value);
  } else {
    entry.set("osm_id",  xmlNode.attributes.id.value);
  }

  entry.set("type",  xmlNode.name);
  var keptAttributes = options[xmlNode.name].keptAttributes;
  var ignoredAttributes = options[xmlNode.name].ignoredAttributes;
  for (var attribute in xmlNode.attributes) {
    // Has it already been used, if so, skip
    if (attribute === "id" || attribute === "lat" || attribute === "lon") continue;
    // Are we excluding some attributes
    if (keptAttributes != undefined) {
      // Is it one that is excluded, if so, skip
      if (!(attribute in keptAttributes)) continue;
    } else { // Some attributes are to be excluded
      if (attribute in ignoredAttributes) continue;
    }
    entry.set(attribute, xmlNode.attributes[attribute].value);
  }
}

function shutDown() {
  save();
  mongoose.connection.close();
}

function save() {
  function handleError( err ) {
    if (!!options.suppressErrors) {
       console.log(err);
    }
  }

  function saveCB( err ) {
    if (!!err) handleError(err);
    if (!!options.verbose) {
      console.log(entry);
      console.log(entry,"\n\n################################################");
    }
  }
  function upsert () {
    var options = {upsert: true};
    var value = entry.toJSON();
    var query = {_id: value._id};
    delete value._id;
    mongoose
      .models[entry.type]
      .findOneAndUpdate(query, value, options, saveCB);
  }

  if (!!options.upsert) {
    upsert();
  } else {
    entry.save(saveCB);
  }
}

