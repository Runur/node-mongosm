#!/usr/bin/env node


/* jshint -W004 */

var fs = require("fs"),
    options = require('options.js');

var mongoose = require("schema/index.js")(options),
    saxStream = require("sax").createStream(options.strict, options);

require('commandline.js')(options);

var Node = mongoose.db.model('node');
var Way = mongoose.db.model('way');
var Relation = mongoose.db.model('relation');
var entry;

mongoose.connection.on('open', function () {

  // TODO: add dots to show activity every 2 sec?
  saxStream.on("opentag", parse);
  fs.createReadStream(options.filename)
    .pipe(saxStream);

  saxStream.on("end", shutDown);

  saxStream.on("error", function (e) {
    console.error("error!", e);
    this._parser.error = null;
    this._parser.resume();
  });
});

function parse (xmlNode)  {

  switch(xmlNode.name)
  {
    
    case "node":
      if (!!entry) {
        save();
      }
      entry = new Node();
      var lat = parseFloat( xmlNode.attributes.lat.value );
      var lng = parseFloat( xmlNode.attributes.lon.value );
      entry.set("_id", xmlNode.attributes.id.value);
      entry.set("loc.coordinates", [lng,lat]);
      entry.set("loc.type", "Point");
      prepBaseNode(xmlNode);
      break;

    case "tag":
      var key   = "tags." + xmlNode.attributes.k.value.replace(/:/, "."),
          value = xmlNode.attributes.v.value;
      entry.set(key, value);
      break;

    case "nd":
      var ref = xmlNode.attributes.ref.value;
      var coord = entry.get("loc", Array) || [];
      coord.push(ref);
      entry.set("loc.coordinates",  coord);
      break;

    case "way":
      if (!!entry) {
        save();
      }
      entry = new Way();
      entry.set("_id", xmlNode.attributes.id.value);
      entry.set("loc",[]);
      prepBaseNode(xmlNode);
      break;

    case "member":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        // TODO: this does not account for namespacing
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      var coord = entry.get("loc.coordinates", Array) || [];

      // TODO: this should be an object not a string
      coord.push(JSON.stringify(val));
      entry.set("loc.coordinates", coord);
      break;

    case "relation":
      if (!!entry) {
        save();
      }
      entry = new Relation();
      entry.set("_id", xmlNode.attributes.id.value);
      entry.set("loc", {type:"MultiPolygon", coordinates: []});
      prepBaseNode(xmlNode);
      break;

    case "osm":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    case "bounds":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    default:
      console.log(xmlNode);
      break;
  }
}

function prepBaseNode (xmlNode) { 
  if (!!options.useOriginalID) {
    entry.set("_id",  xmlNode.attributes.id.value);
  } else {
    entry.set("osm_id",  xmlNode.attributes.id.value);
  }

  entry.set("type",  xmlNode.name);
  for (var attribute in xmlNode.attributes) {
    if (attribute === "id" || attribute === "lat" || attribute === "lon") continue;
    entry.set(attribute, xmlNode.attributes[attribute].value);
  }
}

function shutDown() {
  save();
  console.log("EOF: Ctrl-C to Exit")
  // on small files this closes early
  // implementing manual exit
  // mongoose.connection.close();
}

function save() {
  function upsert () {
    var options = {upsert: true};
    var value = entry.toJSON();
    var query = {_id: value._id};
    delete value._id;
    mongoose
      .models[entry.type]
      .findOneAndUpdate(query, value, options, saveCB);
  }

  if (!!options.upsert) {
    upsert();
  } else {
    entry.save();
  }
}

