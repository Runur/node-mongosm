#!/usr/bin/env node


/* jshint -W004 */

var fs = require("fs"),
    options = require('options.js');

var mongoose = require("schema/index.js")(options),
    saxStream = require("sax").createStream(options.strict, options);

require('commandline.js')(options);

var Node = mongoose.db.model('node');
var Way = mongoose.db.model('way');
var Relation = mongoose.db.model('relation');
var entry;

mongoose.connection.on('open', function () {

  // TODO: add dots to show activity every 2 sec?
  saxStream.on("opentag", parse);
  saxStream.onclosetag = closetag;
  fs.createReadStream(options.filename)
    .pipe(saxStream);

  saxStream.on("end", shutDown);

  saxStream.on("error", function (e) {
    console.error("error!", e);
    this._parser.error = null;
    this._parser.resume();
  });
});

function parse (xmlNode)  {

  switch(xmlNode.name)
  {
    case "node":
      entry = new Node();
      var lat = parseFloat( xmlNode.attributes.lat.value );
      var lng = parseFloat( xmlNode.attributes.lon.value );
      entry.set("loc.coordinates", [lng,lat]);
      entry.set("loc.type", "Point");
      prepBaseNode(xmlNode);
      break;

    case "tag":
      var key   = "tags." + xmlNode.attributes.k.value.replace(/:/, "."),
          value = xmlNode.attributes.v.value;
      entry.set(key, value);
      break;

    case "nd":
      entry.nodes.push(parseInt(xmlNode.attributes.ref.value));
      // These refs are translated to points in the closetag function
      break;

    case "way":
      entry = new Way();
      prepBaseNode(xmlNode);
      entry.nodes = [];
      break;

    case "member":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        // TODO: this does not account for namespacing
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      var coord = entry.get("loc.coordinates", Array) || [];

      // TODO: this should be an object not a string
      coord.push(JSON.stringify(val));
      entry.set("loc.coordinates", coord);
      break;

    case "relation":
      entry = new Relation();
      entry.set("_id", xmlNode.attributes.id.value);
      entry.set("loc", {type:"MultiPolygon", coordinates: []});
      prepBaseNode(xmlNode);
      break;

    case "osm":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    case "bounds":
      var val = {};
      for (var attribute in xmlNode.attributes) {
        val[attribute] = xmlNode.attributes[attribute].value;
      }
      break;

    default:
      console.log(xmlNode);
      break;
  }
}

function closetag (tagName) {
  switch(tagName)
  {
    case "node":
      save(Node, entry);
      break;
    case "way":
      if (options.way.geometry != undefined && options.way.geometry == false) {
        entry.set("loc", undefined);
        if (options.way.nodes == undefined || options.way.nodes == false )
          entry.set("nodes", undefined);

        save(Way, entry);

        break;
      }

      (function(way, nodeRefs) {
        var query = options.useOriginalID ? { _id: { $in: nodeRefs } }: { osm_id: { $in: nodeRefs } };
          Node.find(query, function(err, nodes) {
            if (err) { console.log(err); return; }

            var lookup = {};
            for (var i = 0, len = nodes.length; i < len; i++) {
              lookup[options.useOriginalID ? nodes[i]._id : nodes[i].osm_id] = i;
            }

            var nodeLocs = nodeRefs.map(function (ref) {
              var index = lookup[ref];
              if (index == undefined) {
                // TODO: Fix something so this does not happen!
                console.log("missing node " + ref + " for way " + (options.useOriginalID ? way._id : way.osm_id));
                return [0,0];
              }
              return nodes[index].loc.coordinates;
            });

            // Check if this is a polygon (closed circular way)
            var first = nodeLocs[0];
            var last = nodeLocs.slice(-1)[0];

            if (first[0] === last[0] && first[1] === last[1]) {
              way.loc = { type: 'Polygon', coordinates: [nodeLocs] };
            } else { // This is a LineString
              way.loc = { type: 'LineString', coordinates: nodeLocs };
            }

            if (options.way.nodes == undefined || options.way.nodes == false)
              way.set("nodes", undefined);

            save(Way, way);
          });
        })(entry, entry.nodes.slice()); // Pass in a copy of nodes such that it can be changed
      break;
    case "relation":
      save(Relation, entry);
      break;
  }
}

function prepBaseNode (xmlNode) {
  if (options.useOriginalID == true) {
    entry.set("_id",  xmlNode.attributes.id.value);
  } else {
    entry.set("osm_id",  xmlNode.attributes.id.value);
  }

  entry.set("type",  xmlNode.name);
  for (var attribute in xmlNode.attributes) {
    if (attribute === "id" || attribute === "lat" || attribute === "lon") continue;
    entry.set(attribute, xmlNode.attributes[attribute].value);
  }
}

function shutDown() {
  process.stdout.write("\n\nEOF: Ctrl-C to Exit\n\n");

  // on small files this closes early
  // implementing manual exit
  // mongoose.connection.close();
}

// Saves a object (node, way or relation), the coresponding model (Node, Way, or Relation)
// should also be given as this is used to update (if required).
function save(model, object) {
  if (options.upsert == true) {
    var value = object.toObject();
    var query = options.useOriginalID ? { _id: value._id } : { osm_id: value.osm_id };
    delete value._id;
    model.findOneAndUpdate(query, value, {upsert: true}, function(err) {
      if (err)
        console.log(err);
    });
  } else {
    object.save(function(err) {
      if (err)
        console.log(err);
    });
  }
}

